<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cat Quake - 3D</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
            font-family: 'Courier New', monospace;
        }
        
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #game-canvas {
            display: block;
        }
        
        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #ff0000;
            font-size: 24px;
            text-shadow: 2px 2px 4px #000;
            z-index: 100;
        }
        
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            border: 2px solid #ff0000;
            border-radius: 50%;
            z-index: 100;
            pointer-events: none;
        }
        
        #weapon {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 100px;
            height: 60px;
            background: linear-gradient(45deg, #333, #666);
            border: 2px solid #000;
            z-index: 100;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #ff0000;
            font-weight: bold;
        }
        
        #instructions {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: #ff0000;
            padding: 30px;
            border: 2px solid #ff0000;
            text-align: center;
            z-index: 200;
        }
        
        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="instructions">
            <h1>CAT QUAKE</h1>
            <p>–£–±–µ–π—Ç–µ –≤—Å–µ—Ö –∞–≥—Ä–µ—Å—Å–∏–≤–Ω—ã—Ö –∫–æ—Ç–æ–≤!</p>
            <p>WASD - –¥–≤–∏–∂–µ–Ω–∏–µ</p>
            <p>–ú—ã—à—å - –ø—Ä–∏—Ü–µ–ª–∏–≤–∞–Ω–∏–µ</p>
            <p>–õ–ö–ú - —Å—Ç—Ä–µ–ª—å–±–∞</p>
            <p>–ü—Ä–æ–±–µ–ª - –ø—Ä—ã–∂–æ–∫</p>
            <button onclick="startGame()" style="background: #ff0000; color: white; border: none; padding: 10px 20px; font-size: 18px; cursor: pointer;">–ù–ê–ß–ê–¢–¨</button>
        </div>
        
        <div id="hud">
            <div>–ó–¥–æ—Ä–æ–≤—å–µ: <span id="health">100</span></div>
            <div>–û—á–∫–∏: <span id="score">0</span></div>
            <div>–ö–æ—Ç—ã: <span id="cats-left">10</span></div>
        </div>
        
        <div id="crosshair"></div>
        
        <div id="weapon">
            –î–í–£–°–¢–í–û–õ–ö–ê
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –∏–≥—Ä—ã
        let scene, camera, renderer, playerObject;
        let cats = [];
        let bullets = [];
        let keys = {};
        let mouse = { x: 0, y: 0 };
        let gameStarted = false;
        let gameEnded = false;
        let health = 100;
        let score = 0;
        let catsRemaining = 10;
        
        // –ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∫–∞–º–µ—Ä–æ–π
        let cameraPitch = 0;
        let cameraYaw = 0;
        
        // –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã
        const CAT_COUNT = 10;
        const MAX_CATS = 10;
        const PLAYER_SPEED = 0.1;
        const BULLET_SPEED = 0.5;
        const CAT_SPEED = 0.02;
        const CAT_RESPAWN_TIME = 3000; // 3 —Å–µ–∫—É–Ω–¥—ã
        
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∏–≥—Ä—ã
        function init() {
            // –°–æ–∑–¥–∞–Ω–∏–µ —Å—Ü–µ–Ω—ã
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111111);
            scene.fog = new THREE.Fog(0x111111, 10, 100);
            
            // –°–æ–∑–¥–∞–Ω–∏–µ –æ–±—ä–µ–∫—Ç–∞ –∏–≥—Ä–æ–∫–∞
            playerObject = new THREE.Object3D();
            playerObject.position.set(0, 2, 0);
            scene.add(playerObject);
            
            // –°–æ–∑–¥–∞–Ω–∏–µ –∫–∞–º–µ—Ä—ã –∏ –ø—Ä–∏–∫—Ä–µ–ø–ª–µ–Ω–∏–µ –∫ –∏–≥—Ä–æ–∫—É
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 0); // –ö–∞–º–µ—Ä–∞ –≤ —Ü–µ–Ω—Ç—Ä–µ –∏–≥—Ä–æ–∫–∞
            playerObject.add(camera);
            
            // –°–æ–∑–¥–∞–Ω–∏–µ —Ä–µ–Ω–¥–µ—Ä–µ—Ä–∞
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('game-container').appendChild(renderer.domElement);
            
            // –°–æ–∑–¥–∞–Ω–∏–µ –æ—Å–≤–µ—â–µ–Ω–∏—è
            const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            // –°–æ–∑–¥–∞–Ω–∏–µ –ø–æ–ª–∞
            createFloor();
            
            // –°–æ–∑–¥–∞–Ω–∏–µ —Å—Ç–µ–Ω
            createWalls();
            
            // –°–æ–∑–¥–∞–Ω–∏–µ –∫–æ—Ç–æ–≤
            createCats();
            
            // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è
            setupControls();
            
            // –ó–∞–ø—É—Å–∫ –∏–≥—Ä–æ–≤–æ–≥–æ —Ü–∏–∫–ª–∞
            animate();
        }
        
        function createFloor() {
            const floorGeometry = new THREE.PlaneGeometry(50, 50);
            const floorMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x222222,
                side: THREE.DoubleSide 
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);
        }
        
        function createWalls() {
            // –°–æ–∑–¥–∞–Ω–∏–µ –±–æ–ª–µ–µ –∏–Ω—Ç–µ—Ä–µ—Å–Ω–æ–π –∞—Ä–µ–Ω—ã —Å –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏—è–º–∏
            const wallMaterial = new THREE.MeshLambertMaterial({ color: 0x666666 });
            const obstacleMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
            
            // –í–Ω–µ—à–Ω–∏–µ —Å—Ç–µ–Ω—ã
            const walls = [
                { pos: [0, 2.5, -25], size: [50, 5, 1] },
                { pos: [0, 2.5, 25], size: [50, 5, 1] },
                { pos: [-25, 2.5, 0], size: [1, 5, 50] },
                { pos: [25, 2.5, 0], size: [1, 5, 50] }
            ];
            
            walls.forEach(wall => {
                const geometry = new THREE.BoxGeometry(...wall.size);
                const mesh = new THREE.Mesh(geometry, wallMaterial);
                mesh.position.set(...wall.pos);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                scene.add(mesh);
            });
            
            // –í–Ω—É—Ç—Ä–µ–Ω–Ω–∏–µ –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏—è
            const obstacles = [
                { pos: [0, 1, 0], size: [8, 2, 2] },
                { pos: [0, 1, 10], size: [2, 2, 8] },
                { pos: [-10, 1, -10], size: [6, 2, 6] },
                { pos: [10, 1, -10], size: [6, 2, 6] },
                { pos: [-10, 1, 10], size: [6, 2, 6] },
                { pos: [10, 1, 10], size: [6, 2, 6] },
                { pos: [-15, 1, 0], size: [2, 2, 10] },
                { pos: [15, 1, 0], size: [2, 2, 10] }
            ];
            
            obstacles.forEach(obstacle => {
                const geometry = new THREE.BoxGeometry(...obstacle.size);
                const mesh = new THREE.Mesh(geometry, obstacleMaterial);
                mesh.position.set(...obstacle.pos);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                scene.add(mesh);
            });
        }
        
        function createCat() {
            const catGroup = new THREE.Group();
            
            // –¢–µ–ª–æ –∫–æ—Ç–∞ (–Ω–∏–∑–∫–æ–ø–æ–ª–∏–≥–æ–Ω–∞–ª—å–Ω–æ–µ)
            const bodyGeometry = new THREE.BoxGeometry(0.8, 0.6, 1.2);
            const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.3;
            catGroup.add(body);
            
            // –ì–æ–ª–æ–≤–∞ –∫–æ—Ç–∞
            const headGeometry = new THREE.BoxGeometry(0.6, 0.6, 0.6);
            const headMaterial = new THREE.MeshLambertMaterial({ color: 0xA0522D });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.set(0, 0.6, 0.4);
            catGroup.add(head);
            
            // –£—à–∏
            const earGeometry = new THREE.ConeGeometry(0.15, 0.3, 4);
            const earMaterial = new THREE.MeshLambertMaterial({ color: 0x654321 });
            
            const leftEar = new THREE.Mesh(earGeometry, earMaterial);
            leftEar.position.set(-0.2, 0.9, 0.3);
            leftEar.rotation.x = Math.PI;
            catGroup.add(leftEar);
            
            const rightEar = new THREE.Mesh(earGeometry, earMaterial);
            rightEar.position.set(0.2, 0.9, 0.3);
            rightEar.rotation.x = Math.PI;
            catGroup.add(rightEar);
            
            // –•–≤–æ—Å—Ç
            const tailGeometry = new THREE.CylinderGeometry(0.05, 0.1, 0.8);
            const tailMaterial = new THREE.MeshLambertMaterial({ color: 0x654321 });
            const tail = new THREE.Mesh(tailGeometry, tailMaterial);
            tail.position.set(0, 0.4, -0.8);
            tail.rotation.x = Math.PI / 2;
            catGroup.add(tail);
            
            // –ù–æ–≥–∏
            const legGeometry = new THREE.BoxGeometry(0.15, 0.4, 0.15);
            const legMaterial = new THREE.MeshLambertMaterial({ color: 0x654321 });
            
            const positions = [
                [-0.25, 0.2, 0.4], [0.25, 0.2, 0.4],
                [-0.25, 0.2, -0.4], [0.25, 0.2, -0.4]
            ];
            
            positions.forEach(pos => {
                const leg = new THREE.Mesh(legGeometry, legMaterial);
                leg.position.set(...pos);
                catGroup.add(leg);
            });
            
            return catGroup;
        }
        
        function createCats() {
            for (let i = 0; i < MAX_CATS; i++) {
                const cat = createCat();
                
                // –°–ª—É—á–∞–π–Ω–∞—è –ø–æ–∑–∏—Ü–∏—è –¥–ª—è –∫–æ—Ç–∞
                const pos = getRandomCatPosition();
                cat.position.set(pos.x, pos.y, pos.z);
                
                scene.add(cat);
                cats.push({
                    mesh: cat,
                    health: 100,
                    speed: CAT_SPEED * (0.5 + Math.random() * 0.5),
                    lastAttack: 0,
                    isDead: false,
                    respawnTime: 0
                });
            }
        }
        
        function getRandomCatPosition() {
            let x, z;
            let attempts = 0;
            
            do {
                x = (Math.random() - 0.5) * 40;
                z = (Math.random() - 0.5) * 40;
                attempts++;
                
                // –ü—Ä–æ–≤–µ—Ä–∫–∞, —á—Ç–æ–±—ã –∫–æ—Ç –Ω–µ –ø–æ—è–≤–∏–ª—Å—è —Å–ª–∏—à–∫–æ–º –±–ª–∏–∑–∫–æ –∫ –∏–≥—Ä–æ–∫—É –∏–ª–∏ –≤ –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–∏
            } while ((Math.sqrt(x * x + z * z) < 5 || isPositionBlocked(x, z)) && attempts < 20);
            
            return { x, y: 0, z };
        }
        
        function isPositionBlocked(x, z, radius = 0.5) {
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏—è (—Ç–æ–ª—å–∫–æ –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–µ –±–ª–æ–∫–∏, –≤–Ω–µ—à–Ω–∏–µ —Å—Ç–µ–Ω—ã –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—é—Ç—Å—è –æ—Ç–¥–µ–ª—å–Ω–æ)
            const obstacles = [
                // –í–Ω—É—Ç—Ä–µ–Ω–Ω–∏–µ –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏—è (—É–º–µ–Ω—å—à–µ–Ω–Ω—ã–µ —Ä–∞–¥–∏—É—Å—ã)
                { x: 0, z: 0, radius: 3.5 },
                { x: 0, z: 10, radius: 3.5 },
                { x: -10, z: -10, radius: 2.5 },
                { x: 10, z: -10, radius: 2.5 },
                { x: -10, z: 10, radius: 2.5 },
                { x: 10, z: 10, radius: 2.5 },
                { x: -15, z: 0, radius: 3.0 },
                { x: 15, z: 0, radius: 3.0 }
            ];
            
            return obstacles.some(obstacle => {
                const distance = Math.sqrt((x - obstacle.x) ** 2 + (z - obstacle.z) ** 2);
                return distance < (obstacle.radius + radius);
            });
        }
            
        function checkCollision(newX, newZ, radius = 0.5) {
            return isPositionBlocked(newX, newZ, radius);
        }
        
        function getValidPosition(currentX, currentZ, newX, newZ, radius = 0.5) {
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –º–æ–∂–Ω–æ –ª–∏ –¥–≤–∏–≥–∞—Ç—å—Å—è –≤ –Ω–æ–≤—É—é –ø–æ–∑–∏—Ü–∏—é
            if (!checkCollision(newX, newZ, radius)) {
                return { x: newX, z: newZ };
            }
            
            // –ï—Å–ª–∏ –∫–æ–ª–ª–∏–∑–∏—è, –ø—Ä–æ–±—É–µ–º –¥–≤–∏–≥–∞—Ç—å—Å—è —Ç–æ–ª—å–∫–æ –ø–æ –æ–¥–Ω–æ–π –æ—Å–∏
            if (!checkCollision(newX, currentZ, radius)) {
                return { x: newX, z: currentZ };
            }
            
            if (!checkCollision(currentX, newZ, radius)) {
                return { x: currentX, z: newZ };
            }
            
            // –ï—Å–ª–∏ –≤—Å–µ –µ—â–µ –∫–æ–ª–ª–∏–∑–∏—è, –ø—Ä–æ–±—É–µ–º –¥–≤–∏–≥–∞—Ç—å—Å—è –Ω–∞ –ø–æ–ª–æ–≤–∏–Ω—É —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—è
            const halfDistanceX = (newX - currentX) * 0.5;
            const halfDistanceZ = (newZ - currentZ) * 0.5;
            
            if (!checkCollision(currentX + halfDistanceX, currentZ + halfDistanceZ, radius)) {
                return { x: currentX + halfDistanceX, z: currentZ + halfDistanceZ };
            }
            
            // –ï—Å–ª–∏ –Ω–µ–ª—å–∑—è –¥–≤–∏–≥–∞—Ç—å—Å—è, –æ—Å—Ç–∞–µ–º—Å—è –Ω–∞ –º–µ—Å—Ç–µ
            return { x: currentX, z: currentZ };
        }
            
        function respawnCat(catIndex) {
            const cat = cats[catIndex];
            if (!cat) return;
            
            // –ü–æ–ª—É—á–∞–µ–º –Ω–æ–≤—É—é –ø–æ–∑–∏—Ü–∏—é
            const pos = getRandomCatPosition();
            cat.mesh.position.set(pos.x, pos.y, pos.z);
            
            // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∑–¥–æ—Ä–æ–≤—å–µ –∏ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
            cat.health = 100;
            cat.isDead = false;
            cat.respawnTime = 0;
            cat.lastAttack = 0;
            
            // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –∫–æ—Ç–∞ –∫ –Ω–æ—Ä–º–∞–ª—å–Ω–æ–º—É –ø–æ–ª–æ–∂–µ–Ω–∏—é
            cat.mesh.rotation.z = 0;
            cat.mesh.position.y = 0;
        }
        
        function setupControls() {
            // –ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞
            document.addEventListener('keydown', (event) => {
                keys[event.code] = true;
            });
            
            document.addEventListener('keyup', (event) => {
                keys[event.code] = false;
            });
            
            // –ú—ã—à—å –¥–ª—è –ø–æ–≤–æ—Ä–æ—Ç–∞ –∫–∞–º–µ—Ä—ã
            document.addEventListener('mousemove', (event) => {
                if (gameStarted && !gameEnded && document.pointerLockElement === renderer.domElement) {
                    const movementX = event.movementX || 0;
                    const movementY = event.movementY || 0;
                    
                    // –ü–æ–≤–æ—Ä–æ—Ç –∏–≥—Ä–æ–∫–∞ (yaw) –∏ –∫–∞–º–µ—Ä—ã (pitch)
                    cameraYaw -= movementX * 0.003; // –ü–æ–≤–æ—Ä–æ—Ç –≤–ª–µ–≤–æ/–≤–ø—Ä–∞–≤–æ
                    cameraPitch -= movementY * 0.003; // –ü–æ–≤–æ—Ä–æ—Ç –≤–≤–µ—Ä—Ö/–≤–Ω–∏–∑
                    
                    // –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –ø–æ–≤–æ—Ä–æ—Ç–∞ –ø–æ –≤–µ—Ä—Ç–∏–∫–∞–ª–∏
                    cameraPitch = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1, cameraPitch));
                    
                    // –ü—Ä–∏–º–µ–Ω—è–µ–º –ø–æ–≤–æ—Ä–æ—Ç—ã
                    playerObject.rotation.y = cameraYaw;
                    camera.rotation.x = cameraPitch;
                }
            });
            
            document.addEventListener('click', (event) => {
                if (gameStarted && !gameEnded) {
                    shoot();
                }
            });
            
            // –û–±—Ä–∞–±–æ—Ç–∫–∞ pointer lock
            document.addEventListener('pointerlockchange', () => {
                if (document.pointerLockElement === renderer.domElement) {
                    console.log('‚úÖ Pointer lock –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω - —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –º—ã—à—å—é —Ä–∞–±–æ—Ç–∞–µ—Ç!');
                } else {
                    console.log('‚ùå Pointer lock –¥–µ–∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω - —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –º—ã—à—å—é –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç');
                }
            });
            
            // –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫ pointer lock
            document.addEventListener('pointerlockerror', () => {
                console.log('‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∞–∫—Ç–∏–≤–∞—Ü–∏–∏ pointer lock');
                alert('–ù–µ —É–¥–∞–ª–æ—Å—å –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞—Ç—å –∑–∞—Ö–≤–∞—Ç –º—ã—à–∏. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –æ–±–Ω–æ–≤–∏—Ç—å —Å—Ç—Ä–∞–Ω–∏—Ü—É.');
            });
        }
        
        function startGame() {
            document.getElementById('instructions').classList.add('hidden');
            gameStarted = true;
            
            // –ó–∞—Ö–≤–∞—Ç –º—ã—à–∏
            renderer.domElement.requestPointerLock();
            
            // –û—Ç–ª–∞–¥–æ—á–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è
            console.log('–ò–≥—Ä–∞ –Ω–∞—á–∞–ª–∞—Å—å, –ø—ã—Ç–∞–µ–º—Å—è –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞—Ç—å pointer lock...');
            
            // –ï—Å–ª–∏ pointer lock –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–ª, –ø–æ–∫–∞–∑—ã–≤–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ
            setTimeout(() => {
                if (document.pointerLockElement !== renderer.domElement) {
                    alert('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –Ω–∞–∂–º–∏—Ç–µ –Ω–∞ —ç–∫—Ä–∞–Ω –∏ —Ä–∞–∑—Ä–µ—à–∏—Ç–µ –∑–∞—Ö–≤–∞—Ç –º—ã—à–∏ –¥–ª—è –ª—É—á—à–µ–≥–æ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è!');
                } else {
                    console.log('Pointer lock –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω —É—Å–ø–µ—à–Ω–æ!');
                }
            }, 1000);
        }
        
        function shoot() {
            const bulletGeometry = new THREE.SphereGeometry(0.1);
            const bulletMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
            
            bullet.position.copy(playerObject.position);
            
            // –ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø—É–ª–∏ (–≤–ø–µ—Ä—ë–¥ –æ—Ç –∫–∞–º–µ—Ä—ã)
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction);
            bullet.velocity = direction.multiplyScalar(BULLET_SPEED);
            
            scene.add(bullet);
            bullets.push(bullet);
            
            // –≠—Ñ—Ñ–µ–∫—Ç –æ—Ç–¥–∞—á–∏ (–±–æ–ª–µ–µ –º—è–≥–∫–∏–π, –Ω–µ –æ–ø—É—Å–∫–∞–µ—Ç –ø–æ–¥ –∑–µ–º–ª—é)
            if (playerObject.position.y > 2) {
                playerObject.position.y -= 0.01;
            }
        }
        
        function updatePlayer() {
            if (!gameStarted || gameEnded) return;
            
            const direction = new THREE.Vector3();
            
            // –î–≤–∏–∂–µ–Ω–∏–µ –Ω–∞ –æ—Å–Ω–æ–≤–µ –ø–æ–≤–æ—Ä–æ—Ç–∞ –∏–≥—Ä–æ–∫–∞ (yaw)
            const forward = new THREE.Vector3(0, 0, -1);
            forward.applyAxisAngle(new THREE.Vector3(0, 1, 0), playerObject.rotation.y);
            
            const right = new THREE.Vector3(1, 0, 0);
            right.applyAxisAngle(new THREE.Vector3(0, 1, 0), playerObject.rotation.y);
            
            // –õ–æ–≥–∏–∫–∞ –¥–≤–∏–∂–µ–Ω–∏—è
            if (keys['KeyW']) direction.add(forward);    // –í–ø–µ—Ä—ë–¥
            if (keys['KeyS']) direction.sub(forward);    // –ù–∞–∑–∞–¥
            if (keys['KeyA']) direction.sub(right);      // –í–ª–µ–≤–æ
            if (keys['KeyD']) direction.add(right);      // –í–ø—Ä–∞–≤–æ
            
            if (direction.length() > 0) {
                direction.normalize();
                
                // –í—ã—á–∏—Å–ª—è–µ–º –Ω–æ–≤—É—é –ø–æ–∑–∏—Ü–∏—é —Å –ø—Ä–æ–≤–µ—Ä–∫–æ–π –∫–æ–ª–ª–∏–∑–∏–π
                const newX = playerObject.position.x + direction.x * PLAYER_SPEED;
                const newZ = playerObject.position.z + direction.z * PLAYER_SPEED;
                
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–æ–ª–ª–∏–∑–∏–∏ (—Ä–∞–¥–∏—É—Å –∏–≥—Ä–æ–∫–∞ = 0.5)
                const validPos = getValidPosition(
                    playerObject.position.x, 
                    playerObject.position.z, 
                    newX, 
                    newZ, 
                    0.5
                );
                
                playerObject.position.x = validPos.x;
                playerObject.position.z = validPos.z;
            }
                
            // –ü—Ä—ã–∂–æ–∫
            if (keys['Space'] && playerObject.position.y <= 2) {
                playerObject.position.y += 0.1;
            } else if (playerObject.position.y > 2) {
                playerObject.position.y -= 0.1;
            }
            
            // –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –æ–±–ª–∞—Å—Ç–∏ –∏–≥—Ä—ã (–≤–Ω–µ—à–Ω–∏–µ —Å—Ç–µ–Ω—ã)
            playerObject.position.x = Math.max(-24, Math.min(24, playerObject.position.x));
            playerObject.position.z = Math.max(-24, Math.min(24, playerObject.position.z));
        }
        
        function updateCats() {
            cats.forEach((cat, index) => {
                if (cat.health <= 0 || cat.isDead) return;
                
                // –î–≤–∏–∂–µ–Ω–∏–µ –∫ –∏–≥—Ä–æ–∫—É
                const direction = new THREE.Vector3();
                direction.subVectors(playerObject.position, cat.mesh.position);
                direction.y = 0; // –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–æ–µ –¥–≤–∏–∂–µ–Ω–∏–µ
                direction.normalize();
                
                // –í—ã—á–∏—Å–ª—è–µ–º –Ω–æ–≤—É—é –ø–æ–∑–∏—Ü–∏—é —Å –ø—Ä–æ–≤–µ—Ä–∫–æ–π –∫–æ–ª–ª–∏–∑–∏–π
                const newX = cat.mesh.position.x + direction.x * cat.speed;
                const newZ = cat.mesh.position.z + direction.z * cat.speed;
                
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–æ–ª–ª–∏–∑–∏–∏ —Å –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏—è–º–∏ (—Ä–∞–¥–∏—É—Å –∫–æ—Ç–∞ = 0.4)
                const validPos = getValidPosition(
                    cat.mesh.position.x, 
                    cat.mesh.position.z, 
                    newX, 
                    newZ, 
                    0.4
                );
                
                cat.mesh.position.x = validPos.x;
                cat.mesh.position.z = validPos.z;
                
                // –ü–æ–≤–æ—Ä–æ—Ç –∫–æ—Ç–∞ –∫ –∏–≥—Ä–æ–∫—É
                cat.mesh.lookAt(playerObject.position);
                
                // –ê—Ç–∞–∫–∞ –∫–æ—Ç–∞
                const distance = cat.mesh.position.distanceTo(playerObject.position);
                if (distance < 2 && Date.now() - cat.lastAttack > 1000) {
                    health -= 10;
                    cat.lastAttack = Date.now();
                    updateHUD();
                    
                    if (health <= 0) {
                        endGame(false);
                    }
                }
            });
        }
        
        function updateBullets() {
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                bullet.position.add(bullet.velocity);
                
                // –£–¥–∞–ª–µ–Ω–∏–µ –ø—É–ª–∏, –µ—Å–ª–∏ –æ–Ω–∞ –≤—ã—à–ª–∞ –∑–∞ –ø—Ä–µ–¥–µ–ª—ã
                if (Math.abs(bullet.position.x) > 50 || 
                    Math.abs(bullet.position.z) > 50) {
                    scene.remove(bullet);
                    bullets.splice(i, 1);
                    continue;
                }
                
                // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–π —Å –∫–æ—Ç–∞–º–∏
                cats.forEach((cat, catIndex) => {
                    if (cat.health > 0 && !cat.isDead) {
                        const distance = bullet.position.distanceTo(cat.mesh.position);
                        if (distance < 1) {
                            // –ü–æ–ø–∞–¥–∞–Ω–∏–µ!
                            cat.health -= 50;
                            if (cat.health <= 0) {
                                score += 100;
                                cat.isDead = true;
                                cat.respawnTime = Date.now() + CAT_RESPAWN_TIME;
                                updateHUD();
                                
                                // –í–∏–∑—É–∞–ª—å–Ω—ã–π —ç—Ñ—Ñ–µ–∫—Ç —Å–º–µ—Ä—Ç–∏
                                cat.mesh.rotation.z = Math.PI / 2;
                                cat.mesh.position.y = -1;
                                
                                console.log('üê± –ö–æ—Ç —É–±–∏—Ç! +100 –æ—á–∫–æ–≤');
                            }
                            
                            // –£–¥–∞–ª–µ–Ω–∏–µ –ø—É–ª–∏
                            scene.remove(bullet);
                            bullets.splice(i, 1);
                        }
                    }
                });
            }
        }
                
        function updateRespawn() {
            const currentTime = Date.now();
            let respawnedCount = 0;
            
            cats.forEach((cat, index) => {
                if (cat.isDead && currentTime >= cat.respawnTime) {
                    respawnCat(index);
                    respawnedCount++;
                }
            });
            
            if (respawnedCount > 0) {
                console.log(`üê± ${respawnedCount} –∫–æ—Ç–æ–≤ –≤–æ—Å–∫—Ä–µ—Å–ª–∏!`);
            }
        }
        
        function updateHUD() {
            document.getElementById('health').textContent = health;
            document.getElementById('score').textContent = score;
            document.getElementById('cats-left').textContent = cats.filter(cat => !cat.isDead).length;
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ —É—Å–ª–æ–≤–∏–π –ø–æ–±–µ–¥—ã - –Ω–∞–±—Ä–∞—Ç—å 1000 –æ—á–∫–æ–≤ (10 –∫–æ—Ç–æ–≤ –ø–æ 100 –æ—á–∫–æ–≤)
            if (score >= 1000) {
                endGame(true);
            }
        }
        
        function endGame(won) {
            gameEnded = true;
            const message = won ? '–ü–û–ë–ï–î–ê!' : '–ü–û–†–ê–ñ–ï–ù–ò–ï!';
            const scoreText = `–í–∞—à —Å—á—ë—Ç: ${score}`;
            
            document.getElementById('instructions').innerHTML = `
                <h1>${message}</h1>
                <p>${scoreText}</p>
                <button onclick="location.reload()" style="background: #ff0000; color: white; border: none; padding: 10px 20px; font-size: 18px; cursor: pointer;">–ò–ì–†–ê–¢–¨ –°–ù–û–í–ê</button>
            `;
            document.getElementById('instructions').classList.remove('hidden');
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            updatePlayer();
            updateCats();
            updateBullets();
            updateRespawn();
            
            renderer.render(scene, camera);
        }
        
        // –û–±—Ä–∞–±–æ—Ç–∫–∞ –∏–∑–º–µ–Ω–µ–Ω–∏—è —Ä–∞–∑–º–µ—Ä–∞ –æ–∫–Ω–∞
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // –ó–∞–ø—É—Å–∫ –∏–≥—Ä—ã –ø–æ—Å–ª–µ –∑–∞–≥—Ä—É–∑–∫–∏ —Å—Ç—Ä–∞–Ω–∏—Ü—ã
        window.addEventListener('load', () => {
            init();
        });
    </script>
</body>
</html>